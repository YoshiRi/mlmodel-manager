#!/usr/bin/env bash
set -euo pipefail

PAGE_TOKEN_FLAG="${PAGE_TOKEN_FLAG:---page-token}"
DEFAULT_PAGE_LIMIT="${DEFAULT_PAGE_LIMIT:-30}"   # 0=無制限（全ページ）
DEFAULT_MAX_PAGES="${DEFAULT_MAX_PAGES:-0}"     # 0=無制限

#=== 設定（必要に応じて変更可） ============================================
PROJECT_ID="${WEBAUTO_PROJECT_ID:-prd_jt}"       # envで上書き可
STORE_ROOT="${STORE_ROOT:-/opt/autoware/model-store}"
LINK_ROOT="${LINK_ROOT:-/opt/autoware/mlmodels}"
TARGET_DEFAULT="${TARGET_DEFAULT:-default}"       # 例: x2 等を都度指定可能
LOG_DIR="$HOME/.local/share/autoware-mlswitch"
mkdir -p "$LOG_DIR"

# jqで拾うキー（webautoのJSONに合わせて必要なら微調整）
JQ_PKG_LIST='.packages // .data // .results // .items // . | map({id: (.id // .package_id // .uuid), name: (.name // .package_name)})'
JQ_REL_LIST='.releases // .data // .results // .items // . | map({id: (.id // .release_id // .uuid), version: (.version // .tag // .name // .id)})'

#=== 共通ユーティリティ =====================================================
die(){ echo "Error: $*" >&2; exit 1; }
need(){ command -v "$1" >/dev/null || die "command not found: $1"; }
need webauto; need jq

ensure_dirs(){ sudo mkdir -p "$STORE_ROOT" "$LINK_ROOT"; }

atomically_point_link(){ # $1: link, $2: target
  local link="$1" target="$2" tmp="${1}.tmp.$$"
  [ -e "$target" ] || die "target not found: $target"
  sudo ln -s "$target" "$tmp"
  sudo mv -Tf "$tmp" "$link"     # renameで原子的に置換
}

current_target(){ # $1: link
  readlink -f "$1" 2>/dev/null || true
}

log_switch(){ # $1: model, $2: before, $3: after
  echo "{\"ts\":$(date +%s),\"before\":\"$2\",\"after\":\"$3\"}" | sudo tee -a "$LOG_DIR/$1.jsonl" >/dev/null
}

#=== RELEASE選択の共通部品 ===============================================
# 既存呼び出し互換：limit/max_pages はデフォルト値
fetch_releases_json(){
  local model="$1"
  fetch_releases_json_paged "$model" "$DEFAULT_PAGE_LIMIT" "$DEFAULT_MAX_PAGES"
}

select_release(){ # in: model + (release_id | release_name | version[,target] | latest)
  local model="$1" release_id="$2" release_name="$3" version="$4" target="$5" latest="$6"
  local releases chosen

  # target 指定がある場合、name の prefix で事前フィルタ
  releases="$(fetch_releases_json_paged "$model" 0 0 "$target")"

  if [ -n "$release_id" ]; then
    chosen="$(echo "$releases" | jq -c --arg rid "$release_id" 'map(select(.id==$rid)) | sort_by(.created_at) | last')"
  elif [ -n "$release_name" ]; then
    chosen="$(echo "$releases" | jq -c --arg n "$release_name" 'map(select(.name==$n)) | sort_by(.created_at) | last')"
  elif [ -n "$version" ] && [ -n "$target" ]; then
    chosen="$(echo "$releases" | jq -c --arg v "$version" --arg t "$target" 'map(select(.name==($t+"/"+$v))) | sort_by(.created_at) | last')"
  elif [ -n "$version" ]; then
    chosen="$(echo "$releases" | jq -c --arg v "$version" 'map(select((.name|type=="string") and ((.name|endswith("/"+$v)) or (.name==$v)))) | sort_by(.created_at) | last')"
  elif [ "$latest" = "1" ]; then
    chosen="$(echo "$releases" | jq -c 'sort_by(.created_at) | last')"
  else
    echo "Error: release selector is required (use --latest | --version [--target] | --release-name | --release-id)" >&2
    return 1
  fi

  [ -n "$chosen" ] && [ "$chosen" != "null" ] || { echo "Error: release not found (model=$model selector)" >&2; return 1; }
  echo "$chosen" | jq -r '[.id, .package_id, .name] | @tsv'
}

parse_name_to_target_version(){ # in: name ; out: echo "<target>\t<version>"
  local n="$1"
  if [[ "$n" == */* ]]; then
    echo -e "${n%%/*}\t${n##*/}"
  else
    echo -e "default\t${n}"
  fi
}

#=== リモート release を対話選択 ==========================================
# ローカルに入っている <target>/<version> のキー配列を作る
installed_keys_json(){
  local model="$1" base="$STORE_ROOT/$model"
  [ -d "$base" ] || { echo '[]'; return; }
  find "$base" -mindepth 2 -maxdepth 2 -type d -printf "%P\n" 2>/dev/null \
  | awk -F'/' 'NF==2{print $1"/"$2}' \
  | jq -R -s 'split("\n")|map(select(length>0))'
}

# リモート release を対話選択（インストール済みに印）
pick_release_interactive(){ # out: TSV "<release_id>\t<package_id>\t<name>"
  local model="$1" target_filter="${2:-}" limit="${3:-$DEFAULT_PAGE_LIMIT}" max_pages="${4:-$DEFAULT_MAX_PAGES}"
  local releases installed lines choice

  releases="$(fetch_releases_json_paged "$model" "$limit" "$max_pages" "$target_filter")"
  installed="$(installed_keys_json "$model")"

  [ "$(echo "$releases" | jq 'length')" -gt 0 ] || { echo "no releases found for model=$model target=$target_filter" >&2; return 1; }

# name → <target>/<version> を抽出して「インストール済み」に ✔ を付ける
lines="$(jq -r --argjson inst "$installed" '
  # name: "x2/2.0.0" / "x2/v2.0.0" / "x2/2.0.0_hoge" 等を分解
  #  versionは 1.2 / 1.2.3 / 1.2.3.4 など柔軟に
  def parse_name:
    try (
      capture("^(?<t>[^/]+)/v?(?<v>[0-9]+(?:\\.[0-9]+)+)(?<suf>.*)?$")
    ) catch null;

  def normalized_key($obj):
    if $obj == null then null else "\($obj.t)/\($obj.v)" end;

  def is_installed_exact($obj):
    # サフィックスが「空」のリリースだけを厳密一致の対象にする
    ($obj != null) and (($obj.suf // "") == "") and
    any($inst[]; . == normalized_key($obj));

  sort_by(.created_at) | reverse
  | .[] as $r
  | ($r.name // "") as $n
  | ($n | parse_name) as $p
  | (if is_installed_exact($p) then "✔" else "" end) as $mark
  | [$mark, $n, ($r.created_at // ""), $r.id, $r.package_id] | @tsv
' <<< "$releases")"

if command -v fzf >/dev/null; then
  # ★ タブを区切りに固定。先頭列（mark）は空でも“列として存在”します
  choice="$(printf "%s\n" "$lines" \
    | fzf --delimiter=$'\t' --with-nth=1,2,3 --prompt="select release > ")"
else
  echo "Select release (✔ = installed):"
  # 表示は1〜3列目（mark / name / created_at）
  nl -w2 -s'. ' <(printf "%s\n" "$lines" | cut -f1-3)
  read -r -p "number: " n
  choice="$(printf "%s\n" "$lines" | sed -n "${n}p")"
fi
[ -n "$choice" ] || { echo "selection canceled" >&2; return 1; }

# 列は必ず: 1=mark 2=name 3=created_at 4=release_id 5=package_id
# read ではなく cut -f で厳密に取り出す（IFSや余計な空白の影響を排除）
local rid pid name
rid="$(printf "%s\n" "$choice" | cut -f4)"
pid="$(printf "%s\n" "$choice" | cut -f5)"
name="$(printf "%s\n" "$choice" | cut -f2)"

[ -n "$rid" ] || { echo "parse error: empty release_id in selection" >&2; return 1; }
[ -n "$pid" ] || { echo "parse error: empty package_id in selection" >&2; return 1; }
[ -n "$name" ] || { echo "parse error: empty name in selection" >&2; return 1; }

printf "%s\t%s\t%s\n" "$rid" "$pid" "$name"
}

#=== payload ルート検出（フラット展開用） ===============================
detect_payload_root(){ # $1: tmpdir, $2: model
  local base="$1" model="$2" d="$1"
  # 1) 余計な1段ディレクトリ連結を最大3回まで剥がす（ディレクトリ1個のみ & ファイル0 のとき）
  for _ in 1 2 3; do
    local ndirs nfiles
    ndirs="$(find "$d" -mindepth 1 -maxdepth 1 -type d | wc -l)"
    nfiles="$(find "$d" -mindepth 1 -maxdepth 1 -type f | wc -l)"
    if [ "$nfiles" -eq 0 ] && [ "$ndirs" -eq 1 ]; then
      d="$(find "$d" -mindepth 1 -maxdepth 1 -type d -print -quit)"
    else
      break
    fi
  done

  # 2) d 直下に肝ファイル（*.onnx / *_ml_package.param.yaml / deploy_metadata.yaml）が無ければ、
  #    よくある "<uuid>/<model>" パターンを試す
  if ! find "$d" -maxdepth 1 -type f \( -name '*.onnx' -o -name '*_ml_package.param.yaml' -o -name 'deploy_metadata.yaml' \) | grep -q .; then
    if [ -d "$d/$model" ]; then
      d="$d/$model"
    fi
  fi

  # 3) それでも見つからない場合は、肝ファイルを含む「最も浅い」ディレクトリを探索
  if ! find "$d" -type f \( -name '*.onnx' -o -name '*_ml_package.param.yaml' -o -name 'deploy_metadata.yaml' \) | grep -q .; then
    local cand
    cand="$(find "$base" -type f \( -name '*.onnx' -o -name '*_ml_package.param.yaml' -o -name 'deploy_metadata.yaml' \) -printf '%h\n' \
            | awk -F/ '{print NF, $0}' | sort -n | head -1 | cut -d' ' -f2-)"
    if [ -n "$cand" ]; then d="$cand"; fi
  fi

  echo "$d"
}

#=== releases をページングで全件（or制限付き）集約 ======================
# 引数: $1=model, $2=limit(件数上限; 0=無制限), $3=max_pages(0=無制限), $4=optional target filter (name prefix)
# 出力: 単一の JSON 配列（各要素が release オブジェクト）
fetch_releases_json_paged(){
  local model="$1" limit="${2:-$DEFAULT_PAGE_LIMIT}" max_pages="${3:-$DEFAULT_MAX_PAGES}" target_filter="${4:-}"
  local token="" page=0
  local agg tmp resp cur next
  tmp="$(mktemp)"; echo "[]" > "$tmp"

  while :; do
    # 1) 呼び出し（トークン有無で切替）
    if [ -n "$token" ]; then
      resp="$(webauto ml package-release search --project-id "$PROJECT_ID" --package-name "$model" "$PAGE_TOKEN_FLAG" "$token" --output json)"
    else
      resp="$(webauto ml package-release search --project-id "$PROJECT_ID" --package-name "$model" --output json)"
    fi

    # 2) 今ページの releases 配列を抽出（フィールド名ゆらぎ吸収）
    cur="$(echo "$resp" | jq -c '(.releases // .data // .results // .items // .) as $x | if ($x|type)=="array" then $x else [$x] end')"

    # 3) target フィルタ（name の接頭辞が "<target>/"）
    if [ -n "$target_filter" ]; then
      cur="$(echo "$cur" | jq -c --arg t "$target_filter" '[ .[] | select((.name|type=="string") and (.name|startswith($t+"/"))) ]')"
    fi

    # 4) 集約に加える
    jq -c --argjson add "$cur" '. + $add' "$tmp" > "${tmp}.new" && mv "${tmp}.new" "$tmp"

    # 5) 件数上限チェック
    if [ "$limit" -gt 0 ]; then
      local count
      count="$(jq 'length' "$tmp")"
      if [ "$count" -ge "$limit" ]; then
        # 上限超過分を落とす
        jq -c --argjson n "$limit" '.[0:$n]' "$tmp" > "${tmp}.new" && mv "${tmp}.new" "$tmp"
        break
      fi
    fi

    # 6) 次ページ判定・回数上限
    next="$(echo "$resp" | jq -r '.next_page_token // empty')"
    page=$((page+1))
    if [ -z "$next" ]; then break; fi
    if [ "$max_pages" -gt 0 ] && [ "$page" -ge "$max_pages" ]; then break; fi
    token="$next"
  done

  cat "$tmp"
  rm -f "$tmp"
}

#=== 1) モデル一覧 ==========================================================
cmd_list_models(){
  webauto ml package list --project-id "$PROJECT_ID" --output json \
    | jq -r "$JQ_PKG_LIST | .[] | \"\(.id)\t\(.name)\"" \
    || die "failed to list packages"
}

#=== 2) リリース一覧（モデル名指定） ========================================

cmd_list_releases(){
  local model="${1:-}"; [ -n "$model" ] || die "usage: mlpoc releases <model-name>"
  webauto ml package-release search --project-id "$PROJECT_ID" --package-name "$model" --output json \
    | jq -r "$JQ_REL_LIST | .[] | \"\(.id)\t\(.version)\"" \
    || die "failed to list releases"
}

#=== 3) 取得＆配置＆リンク切替 ==============================================
#=== 3a) pull（切替なし） =================================================
cmd_pull(){
  local model="" release_id="" release_name="" version_override="" target="" latest="0" output_json="0"
  local payload_subdir="" pick="0"
  local limit="$DEFAULT_PAGE_LIMIT" max_pages="$DEFAULT_MAX_PAGES"

  # 位置引数: <model> [<target>/<version>]
  if [[ $# -gt 0 && "$1" != --* ]]; then
    model="$1"; shift
    if [[ $# -gt 0 && "$1" =~ ^[^/]+/[^/]+$ ]]; then
      target="${1%%/*}"
      version_override="${1##*/}"
      shift
    fi
  fi

  while [[ $# -gt 0 ]]; do
    case "$1" in
      --model) model="$2"; shift 2;;
      --release-id) release_id="$2"; shift 2;;
      --release-name) release_name="$2"; shift 2;;
      --version) version_override="$2"; shift 2;;
      --target) target="$2"; shift 2;;
      --latest) latest="1"; shift;;
      --pick) pick="1"; shift;;
      --limit) limit="$2"; shift 2;;
      --max-pages) max_pages="$2"; shift 2;;
      --project-id) PROJECT_ID="$2"; shift 2;;
      --json) output_json="1"; shift;;
      --payload-subdir) payload_subdir="$2"; shift 2;;
      *) die "unknown arg: $1";;
    esac
  done
  [ -n "$model" ] || die "usage: mlpoc pull <model> [<target>/<version>] [--pick | --latest | --version <ver> [--target <tgt>] | --release-name <name> | --release-id <rid>] [--limit N] [--max-pages M] [--project-id <pid>] [--json] [--payload-subdir <relpath>]"

  ensure_dirs

  # セレクタ未指定なら自動で対話選択に
  if [ -z "$release_id$release_name$version_override$target" ] && [ "$latest" = "0" ] && [ "$pick" = "0" ]; then
    pick=1
  fi

  # リリース解決
  local rid pid rname
  if [ "$pick" = "1" ]; then
    IFS=$'\t' read -r rid pid rname < <(pick_release_interactive "$model" "$target" "$limit" "$max_pages")
  else
    IFS=$'\t' read -r rid pid rname < <(select_release "$model" "$release_id" "$release_name" "$version_override" "$target" "$latest")
  fi

  [ -n "$rid" ] || die "failed to resolve release_id (selector/pick)"
  [ -n "$pid" ] || die "failed to resolve package_id (selector/pick)"
  [ -n "$rname" ] || die "failed to resolve release name"

  # name → target/version
  local parsed_target parsed_version
  IFS=$'\t' read -r parsed_target parsed_version < <(parse_name_to_target_version "$rname")

  # pull
  local tmpdir; tmpdir="$(mktemp -d)"
  webauto ml package-release pull \
    --project-id "$PROJECT_ID" \
    --package-id "$pid" \
    --package-release-id "$rid" \
    --target-dir "$tmpdir" \
    --output json --quiet >/dev/null

  local version="${version_override:-$parsed_version}"
  local target_final="${target:-$parsed_target}"

  # 原子的配置
  local dest="$STORE_ROOT/$model/$target_final/$version"
  local staging; staging="$(mktemp -d --tmpdir "$model.$target_final.$version.staging.XXXX")"
  sudo mkdir -p "$(dirname "$dest")"
  [ -z "$(ls -A "$tmpdir")" ] && die "pulled dir is empty: $tmpdir"

  # フラット展開
  local payload_root
  if [ -n "$payload_subdir" ]; then
    [ -d "$tmpdir/$payload_subdir" ] || die "--payload-subdir invalid: $payload_subdir"
    payload_root="$tmpdir/$payload_subdir"
  else
    payload_root="$(detect_payload_root "$tmpdir" "$model")"
  fi

  sudo cp -a "$payload_root"/. "$staging"/
  rm -rf "$tmpdir"

  # 検証
  if ! sudo find "$staging" -type f -name '*.onnx' | grep -q .; then
    sudo rm -rf "$staging"; die "no .onnx found in staging"
  fi

  sudo rm -rf "$dest"
  sudo mv -T "$staging" "$dest"

  if [ "$output_json" = "1" ]; then
    printf '{"model":"%s","target":"%s","version":"%s","path":"%s","release_id":"%s","package_id":"%s","name":"%s"}\n' \
      "$model" "$target_final" "$version" "$dest" "$rid" "$pid" "$rname"
  else
    echo "installed to: $dest  (release: $rname)"
  fi
}

#=== 3b) pull + switch =====================================================
cmd_pull_switch(){
  # 引数仕様は cmd_pull と同じ + --no-switch（既存互換）
  local no_switch="0"
  # いったん pull を呼び、最後にスイッチまでやる
  local args=()
  while [[ $# -gt 0 ]]; do
    case "$1" in
      --no-switch) no_switch="1"; shift;;
      *) args+=("$1"); shift;;
    esac
  done

  # pullを実行して結果JSONを受け取る
  local result; result="$(cmd_pull "${args[@]}" --json)"
  local model path; model="$(echo "$result" | jq -r .model)"; path="$(echo "$result" | jq -r .path)"

  if [ "$no_switch" = "1" ]; then
    echo "$result"
    echo "(--no-switch のため参照は変更していません)"
    return 0
  fi

  # switch
  ensure_dirs
  local link="$LINK_ROOT/$model"
  local before; before="$(current_target "$link")"
  atomically_point_link "$link" "$path"
  log_switch "$model" "${before:-}" "$path"
  echo "switched: $link -> $path"
}

#=== 4) 現在の参照確認・手動切替 ============================================
cmd_current(){ local model="$1"; [ -n "$model" ] || die "usage: mlpoc current <model>"; current_target "$LINK_ROOT/$model"; }
cmd_switch(){
  # 互換: 第二引数が絶対パスなら従来どおりパス指定モード
  if [[ "${2:-}" == /* ]]; then
    local model="$1" target_path="$2"
    [ -n "$model" ] && [ -n "$target_path" ] || die "usage: mlpoc switch <model> <abs-target-path>"
    ensure_dirs
    local link="$LINK_ROOT/$model"
    local before; before="$(current_target "$link")"
    [ -d "$target_path" ] || die "not a dir: $target_path"
    if ! find "$target_path" -type f -name '*.onnx' | grep -q .; then die "no .onnx under $target_path"; fi
    atomically_point_link "$link" "$target_path"
    log_switch "$model" "${before:-}" "$target_path"
    echo "switched: $link -> $target_path"
    return
  fi

  # 新: model + (--target/--version | --latest --target | --pick)
  local model="" target="" version="" latest=0 pick=0
  model="$1"; shift || true
  while [[ $# -gt 0 ]]; do
    case "$1" in
      --target)  target="$2"; shift 2;;
      --version) version="$2"; shift 2;;
      --latest)  latest=1;   shift;;
      --pick)    pick=1;     shift;;
      *) die "usage: mlpoc switch <model> (--target <tgt> --version <ver> | --latest --target <tgt> | --pick [--target <tgt>])";;
    esac
  done
  [ -n "$model" ] || die "usage: mlpoc switch <model> ..."

  local target_path=""
  if [ "$pick" = "1" ]; then
    # 一覧生成
    mapfile -t rows < <(list_local_tsv "$model")
    [ ${#rows[@]} -gt 0 ] || die "no installed entries for model=$model"

    # target 指定があれば絞り込み
    if [ -n "$target" ]; then
      rows=( $(printf "%s\n" "${rows[@]}" | awk -F'\t' -v t="$target" '$1==t {print}') )
      [ ${#rows[@]} -gt 0 ] || die "no entries for model=$model target=$target"
    fi

    # fzf があれば使う、無ければ番号選択
    local choice
    if command -v fzf >/dev/null; then
      choice="$(printf "%s\n" "${rows[@]}" \
        | sort -t$'\t' -k1,1 -k2,2V \
        | awk -F'\t' '{printf "%s/%s\t%s\n",$1,$2,$3}' \
        | fzf --prompt="select target/version > " | cut -f2)"
    else
      echo "Select entry:"
      nl -w2 -s'. ' <(printf "%s\n" "${rows[@]}" \
        | sort -t$'\t' -k1,1 -k2,2V \
        | awk -F'\t' '{printf "%s/%s\t%s\n",$1,$2,$3}')
      read -r -p "number: " n
      choice="$(printf "%s\n" "${rows[@]}" \
        | sort -t$'\t' -k1,1 -k2,2V \
        | awk -F'\t' '{printf "%s/%s\t%s\n",$1,$2,$3}' | sed -n "${n}p" | cut -f2)"
    fi
    [ -n "$choice" ] || die "no selection"
    target_path="$choice"
  else
    [ -n "$target" ] || die "--target is required (or use --pick)"
    if [ -z "$version" ]; then
      if [ "$latest" = "1" ]; then
        version="$(find "$STORE_ROOT/$model/$target" -mindepth 1 -maxdepth 1 -type d -printf "%f\n" | sort -V | tail -1)"
        [ -n "$version" ] || die "no versions under $STORE_ROOT/$model/$target"
      else
        die "--version is required unless --latest or --pick"
      fi
    fi
    target_path="$STORE_ROOT/$model/$target/$version"
  fi

  ensure_dirs
  local link="$LINK_ROOT/$model"
  local before; before="$(current_target "$link")"
  [ -d "$target_path" ] || die "not a dir: $target_path"
  if ! find "$target_path" -type f -name '*.onnx' | grep -q .; then die "no .onnx under $target_path"; fi
  atomically_point_link "$link" "$target_path"
  log_switch "$model" "${before:-}" "$target_path"
  echo "switched: $link -> $target_path"
}

#=== ローカルのインストール済み候補を TSV/JSON で取得 ====================
list_local_tsv(){ # $1: model -> outputs: "<target>\t<version>\t<path>"
  local model="$1" base="$STORE_ROOT/$model"
  [ -d "$base" ] || return 0
  for t in "$base"/*; do
    [ -d "$t" ] || continue
    local tgt="${t##*/}"
    for v in "$t"/*; do
      [ -d "$v" ] || continue
      local ver="${v##*/}"
      echo -e "$tgt\t$ver\t$v"
    done
  done
}

cmd_list_local(){
  local model="" json=0 target=""
  if [[ $# -ge 1 && "$1" != "--json" && "$1" != "--target" ]]; then model="$1"; shift; fi
  while [[ $# -gt 0 ]]; do
    case "$1" in
      --json) json=1; shift;;
      --target) target="$2"; shift 2;;
      *) break;;
    esac
  done

  if [ -z "$model" ]; then
    [ -d "$STORE_ROOT" ] || exit 0
    find "$STORE_ROOT" -mindepth 1 -maxdepth 1 -type d -printf "%f\n" | sort
    return
  fi

  local base="$STORE_ROOT/$model"
  local cur="$(readlink -f "$LINK_ROOT/$model" 2>/dev/null || true)"

  # 収集（target,version,path）
  mapfile -t rows < <(
    [ -d "$base" ] || true
    find "$base" -mindepth 2 -maxdepth 2 -type d -printf "%P\t%p\n" 2>/dev/null \
    | awk -F'\t' 'NF==2' \
    | awk -F'[\t/]' '{printf "%s\t%s\t%s\n",$1,$2,$3}'
  )

  if [ "$json" = "1" ]; then
    printf "%s\n" "${rows[@]}" \
    | jq -R -s --arg cur "$cur" '
        split("\n")|map(select(length>0)|split("\t"))|
        map({target:.[0],version:.[1],path:("\($ENV.STORE_ROOT)/'"$model"'/\(.target)/\(.version)"),
             is_current:(($cur!="") and ($cur==("\($ENV.STORE_ROOT)/'"$model"'/\(.target)/\(.version)")))})
      ' \
      | jq 'sort_by(.target,.version)'
  else
    echo "model: $model"
    echo -e "used\ttarget\tversion\tpath"
    for line in "${rows[@]}"; do
      IFS=$'\t' read -r tgt ver path <<< "$line"
      local p="$STORE_ROOT/$model/$tgt/$ver"
      local mark=" "
      [ -n "$cur" ] && [ "$cur" = "$p" ] && mark="✔"
      printf "%s\t%s\t%s\t%s\n" "$mark" "$tgt" "$ver" "$p"
    done | sort -t$'\t' -k2,2 -k3,3V
  fi
  }

#=== エントリポイント ========================================================
case "${1:-}" in
  models)      shift; cmd_list_models "$@";;
  releases)    shift; cmd_list_releases "$@";;
  pull)        shift; cmd_pull "$@";;
  pull-switch) shift; cmd_pull_switch "$@";;
  list)        shift; cmd_list_local "$@";;
  current)     shift; cmd_current "$@";;
  switch)      shift; cmd_switch "$@";;
  *)
    cat <<'EOF'
Usage:
  # リモート一覧（webauto）
  mlpoc models
  mlpoc releases <model-name>

  # ローカルにインストール済みの候補を表示
  mlpoc list                      # モデル名のみ一覧
  mlpoc list <model>              # <target>/<version>/path の一覧
  mlpoc list <model> --json       # JSON で出力

  # 取得のみ（配置するが参照は切替えない）
  # 位置引数でも指定可: mlpoc pull <model> [<target>/<version>]
  sudo mlpoc pull <model> [<target>/<version>] \
    [--pick | --latest | --version <ver> [--target <tgt>] | --release-name <name> | --release-id <rid>] \
    [--limit N] [--max-pages M] [--project-id <pid>] [--json] [--payload-subdir <relpath>]

  # 取得して参照も切替
  sudo mlpoc pull-switch --model <name> \
    [--pick | --latest | --version <ver> [--target <tgt>] | --release-name <name> | --release-id <rid>] \
    [--limit N] [--max-pages M] [--project-id <pid>] [--no-switch]

  # 現在の参照確認 / 既存実体へ手動切替
  mlpoc current <model>

  # 参照切替（パス不要、target/version 指定 or 対話選択）
  sudo mlpoc switch <model> --target <tgt> --version <ver>
  sudo mlpoc switch <model> --latest --target <tgt>
  sudo mlpoc switch <model> --pick            # fzf があれば fzf、無ければ番号選択
  # 互換: パス直接指定も可
  sudo mlpoc switch <model> /opt/autoware/model-store/<model>/<target>/<version>

Options:
  --latest                   （pull/pull-switch/switch）候補のうち最新を選択
  --pick                     （pull/pull-switch/switch）対話選択。--target で候補を絞り込み可
  --target <tgt>             例: xx1, x2
  --version <ver>            例: 2.3.1
  --release-name <name>      例: "xx1/2.3.1"
  --release-id <rid>         直接ID
  --limit N                  リリース探索の件数上限（既定: 30, 0=無制限）
  --max-pages M              取得ページ上限（既定: 0=無制限）
  --project-id <pid>         既定=WEBAUTO_PROJECT_ID または prd_jt
  --json                     JSON出力（pull/list）
  --payload-subdir <relpath> pull後の展開ルートを手動指定

Env:
  WEBAUTO_PROJECT_ID   (default: prd_jt)
  STORE_ROOT           (default: /opt/autoware/model-store)
  LINK_ROOT            (default: /opt/autoware/mlmodels)
  TARGET_DEFAULT       (default: default)
  DEFAULT_PAGE_LIMIT   (default: 30)
  DEFAULT_MAX_PAGES    (default: 0)
  PAGE_TOKEN_FLAG      (default: --page-token)

Notes:
  * /opt/autoware 配下の書換や参照切替には sudo が必要です。
  * pull の位置引数 <model> [<target>/<version>] は --model/--target/--version に読み替えます。
  * list はローカルの実体を走査、switch は --target/--version からパスを自動解決します。
EOF
    ;;
esac
